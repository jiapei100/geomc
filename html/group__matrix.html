<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>geomc: Matrix</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">geomc
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A c++ linear algebra template library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Matrix<div class="ingroups"><a class="el" href="group__linalg.html">Linalg</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Matrix-related functions and classes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_p_l_u_decomposition.html">PLUDecomposition&lt; T, M, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the PLU decompostion for a matrix <code>A</code>, such that <code>PA = LU</code>.  <a href="classgeom_1_1_p_l_u_decomposition.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_augmented_matrix.html">AugmentedMatrix&lt; Ma, Mb &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix which wraps two side-by-side sub-matrices.  <a href="classgeom_1_1_augmented_matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_diag_matrix.html">DiagMatrix&lt; T, M, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix with nonzero elements only along the main diagonal.  <a href="classgeom_1_1_diag_matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_matrix.html">Matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic matrix class which can hold references to all other matrix types.  <a href="classgeom_1_1_matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_permutation_matrix.html">PermutationMatrix&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix which, by multiplication, permutes the rows or columns of another matrix.  <a href="classgeom_1_1_permutation_matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_simple_matrix.html">SimpleMatrix&lt; T, M, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic matrix with <code>M x N</code> elements.  <a href="classgeom_1_1_simple_matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeom_1_1_sparse_matrix.html">SparseMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (still weakly-supported) class which only stores nonzero matrix elements.  <a href="classgeom_1_1_sparse_matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab21d5043e723f853c25239014392b5f6"><td class="memTemplParams" colspan="2">template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:gab21d5043e723f853c25239014392b5f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gab21d5043e723f853c25239014392b5f6">mtx_aliases_storage</a> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:gab21d5043e723f853c25239014392b5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33456f94a9ec6f71bf5bd3016ec787e3"><td class="memTemplParams" colspan="2">template&lt;typename Md , typename Ms &gt; </td></tr>
<tr class="memitem:ga33456f94a9ec6f71bf5bd3016ec787e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga33456f94a9ec6f71bf5bd3016ec787e3">mtxcopy</a> (Md *into, const Ms &amp;src)</td></tr>
<tr class="separator:ga33456f94a9ec6f71bf5bd3016ec787e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2513740215784239349db200787eac"><td class="memTemplParams" colspan="2">template&lt;typename Md , typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:ga1f2513740215784239349db200787eac"><td class="memTemplItemLeft" align="right" valign="top">Md &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga1f2513740215784239349db200787eac">mul</a> (Md *into, const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:ga1f2513740215784239349db200787eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6fff1cabd69e3baba0e775e0afe9ca3"><td class="memTemplParams" colspan="2">template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:gab6fff1cabd69e3baba0e775e0afe9ca3"><td class="memTemplItemLeft" align="right" valign="top">Md&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gab6fff1cabd69e3baba0e775e0afe9ca3">mul</a> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:gab6fff1cabd69e3baba0e775e0afe9ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga293381c8fe7ffa4ed9889db1f4ca7787"><td class="memTemplParams" colspan="2">template&lt;typename Md , typename Mx &gt; </td></tr>
<tr class="memitem:ga293381c8fe7ffa4ed9889db1f4ca7787"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga293381c8fe7ffa4ed9889db1f4ca7787">transpose</a> (Md *into, const Mx &amp;m)</td></tr>
<tr class="separator:ga293381c8fe7ffa4ed9889db1f4ca7787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7817e9ff690b0dbf2baa4475bbd5f8ca"><td class="memTemplParams" colspan="2">template&lt;typename Mx &gt; </td></tr>
<tr class="memitem:ga7817e9ff690b0dbf2baa4475bbd5f8ca"><td class="memTemplItemLeft" align="right" valign="top">Md&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga7817e9ff690b0dbf2baa4475bbd5f8ca">transpose</a> (const Mx &amp;m)</td></tr>
<tr class="separator:ga7817e9ff690b0dbf2baa4475bbd5f8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga289fd7275b5cabfe4506146872626c29"><td class="memTemplParams" colspan="2">template&lt;typename Md , typename Mx &gt; </td></tr>
<tr class="memitem:ga289fd7275b5cabfe4506146872626c29"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga289fd7275b5cabfe4506146872626c29">inv</a> (Md *into, const Mx &amp;src)</td></tr>
<tr class="separator:ga289fd7275b5cabfe4506146872626c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd2ee70cec8b19d14ac6227faaaf022f"><td class="memTemplParams" colspan="2">template&lt;typename Mx &gt; </td></tr>
<tr class="memitem:gafd2ee70cec8b19d14ac6227faaaf022f"><td class="memTemplItemLeft" align="right" valign="top">Md&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gafd2ee70cec8b19d14ac6227faaaf022f">inv</a> (const Mx &amp;m, bool *success)</td></tr>
<tr class="separator:gafd2ee70cec8b19d14ac6227faaaf022f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4a33c0f1bb911ce5235ceb09dca799a"><td class="memTemplParams" colspan="2">template&lt;typename Md , typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:gaa4a33c0f1bb911ce5235ceb09dca799a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gaa4a33c0f1bb911ce5235ceb09dca799a">add</a> (Md *d, const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:gaa4a33c0f1bb911ce5235ceb09dca799a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca8a4cc286eb011023e4c4adae9e27b"><td class="memTemplParams" colspan="2">template&lt;typename Md , typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:ga4ca8a4cc286eb011023e4c4adae9e27b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga4ca8a4cc286eb011023e4c4adae9e27b">sub</a> (Md *d, const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:ga4ca8a4cc286eb011023e4c4adae9e27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15d4fd8bba9f23ca2fb70cd0d4770f63"><td class="memTemplParams" colspan="2">template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:ga15d4fd8bba9f23ca2fb70cd0d4770f63"><td class="memTemplItemLeft" align="right" valign="top">Md&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga15d4fd8bba9f23ca2fb70cd0d4770f63">add</a> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:ga15d4fd8bba9f23ca2fb70cd0d4770f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb3d20f8e69be52e491533ecbba17cbd"><td class="memTemplParams" colspan="2">template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:gacb3d20f8e69be52e491533ecbba17cbd"><td class="memTemplItemLeft" align="right" valign="top">Md&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gacb3d20f8e69be52e491533ecbba17cbd">sub</a> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:gacb3d20f8e69be52e491533ecbba17cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4972da3cb8b6c6a34ef1615caad4bb1d"><td class="memTemplParams" colspan="2">template&lt;typename U typename Mx, typename Md &gt; </td></tr>
<tr class="memitem:ga4972da3cb8b6c6a34ef1615caad4bb1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga4972da3cb8b6c6a34ef1615caad4bb1d">scale</a> (Md *d, U k, const Mx &amp;m)</td></tr>
<tr class="separator:ga4972da3cb8b6c6a34ef1615caad4bb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50aba1796182cf79911df6fd74d7494f"><td class="memTemplParams" colspan="2">template&lt;typename U typename Mx&gt; </td></tr>
<tr class="memitem:ga50aba1796182cf79911df6fd74d7494f"><td class="memTemplItemLeft" align="right" valign="top">Mx&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga50aba1796182cf79911df6fd74d7494f">scale</a> (U k, const Mx &amp;m)</td></tr>
<tr class="separator:ga50aba1796182cf79911df6fd74d7494f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0002aa703c848adc96acb4714785baaa"><td class="memTemplParams" colspan="2">template&lt;typename U , typename Mx &gt; </td></tr>
<tr class="memitem:ga0002aa703c848adc96acb4714785baaa"><td class="memTemplItemLeft" align="right" valign="top">Mx&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga0002aa703c848adc96acb4714785baaa">operator*</a> (U k, const Mx &amp;m)</td></tr>
<tr class="separator:ga0002aa703c848adc96acb4714785baaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga948c769c294a93b817cb05f1c2a15eeb"><td class="memTemplParams" colspan="2">template&lt;typename U , typename Mx &gt; </td></tr>
<tr class="memitem:ga948c769c294a93b817cb05f1c2a15eeb"><td class="memTemplItemLeft" align="right" valign="top">Mx&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga948c769c294a93b817cb05f1c2a15eeb">operator*</a> (const Mx &amp;m, U k)</td></tr>
<tr class="separator:ga948c769c294a93b817cb05f1c2a15eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6502d1b57b8306893b83c0acf776bd7f"><td class="memTemplParams" colspan="2">template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:ga6502d1b57b8306893b83c0acf776bd7f"><td class="memTemplItemLeft" align="right" valign="top">Mx&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga6502d1b57b8306893b83c0acf776bd7f">operator+</a> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:ga6502d1b57b8306893b83c0acf776bd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada3c858a1219dc51e34e8c6eff00d155"><td class="memTemplParams" colspan="2">template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:gada3c858a1219dc51e34e8c6eff00d155"><td class="memTemplItemLeft" align="right" valign="top">Mx&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gada3c858a1219dc51e34e8c6eff00d155">operator-</a> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:gada3c858a1219dc51e34e8c6eff00d155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cf1ff3da39cde1d3419a32a4343dc20"><td class="memTemplParams" colspan="2">template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:ga2cf1ff3da39cde1d3419a32a4343dc20"><td class="memTemplItemLeft" align="right" valign="top">Mx&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga2cf1ff3da39cde1d3419a32a4343dc20">operator*</a> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:ga2cf1ff3da39cde1d3419a32a4343dc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5acc85c8aa5280f24693d04b24855589"><td class="memTemplParams" colspan="2">template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:ga5acc85c8aa5280f24693d04b24855589"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#ga5acc85c8aa5280f24693d04b24855589">operator==</a> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:ga5acc85c8aa5280f24693d04b24855589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40b28b9ab295b246f08a49e6b3d99fb"><td class="memTemplParams" colspan="2">template&lt;typename Ma , typename Mb &gt; </td></tr>
<tr class="memitem:gae40b28b9ab295b246f08a49e6b3d99fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix.html#gae40b28b9ab295b246f08a49e6b3d99fb">operator!=</a> (const Ma &amp;a, const Mb &amp;b)</td></tr>
<tr class="separator:gae40b28b9ab295b246f08a49e6b3d99fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Matrix-related functions and classes. </p>
<h1>Include </h1>
<p><code>#include &lt;<a class="el" href="_matrix_8h_source.html">geomc/linalg/Matrix.h</a>&gt;</code></p>
<h1>Design</h1>
<p>There are currently six distinct matrix template classes. They are all interoperable, and provide iterators which are functionally interchangeable with each other and with pointers (row iterators, column iterators, region iterators, and row-major matrix body iterators).</p>
<p>These iterators are compatible with std::copy(). Some of them are not writeable (or may possibly throw an error upon writing) in the case where a matrix element does not have a corresponding memory location (DiagonalMatrix is one such case, for example; off-diagonals are not stored).</p>
<p>In general, this scheme was designed to satisfy the following requirements:</p>
<ul>
<li>All matrix types must interoperate readily.</li>
<li>Using matrices with arithmetic operators should be straightforward, efficient, and feel like using a native type.</li>
<li>Dimension mismatches should be caught at compile time wherever possible, to avoid unnecessary runtime checks.</li>
<li>Element access shall be non-virtual and inline-able wherever possible.</li>
<li>Dynamic memory allocations should be minimized wherever possible.</li>
<li>Copies to and from contiguous memory shall be fast where the internal matrix representation is contiguous.</li>
<li>Handles to matrices of arbitrary type are possible.</li>
</ul>
<h1>Use</h1>
<h2>Matrix dimensions</h2>
<p>Most matrices have templated size: </p>
<pre class="fragment">SimpleMatrix&lt;double, 3, 4&gt; mat3x4;
</pre><p>In the example above, we construct a matrix with 3 rows and 4 columns. This matrix has <b>static dimensions</b>, in that its size is chosen (and fixed) at compile-time. Matrices with dimensions chosen at runtime may be written as: </p>
<pre class="fragment">SimpleMatrix&lt;double, 0, 0&gt; matNxN(nrows, ncols);
</pre><p>There are two important functional differences between static matrices and dynamic matrices:</p>
<ul>
<li>Static matrix operators may perform dimension "agreement" checks at compile-time, catching errors early, and circumventing the cost of runtime dimension checks.</li>
<li>Static matrices use "copy" semantics, while dynamic matrices use "reference" semantics, and refer to common storage when copy-constructed.</li>
</ul>
<p>The latter point is important to understand, as writing: </p>
<pre class="fragment">SimpleMatrix&lt;double, 0, 0&gt; m1 = some_matrix_function(...);
SimpleMatrix&lt;double, 0, 0&gt; m2 = m1;
m2[1][2] = 123;
</pre><p>means that element <code>(1, 2)</code> is altered in <em>both</em> <code>m1</code> and <code>m2</code>. This is <b>not</b> the case with static matrices.</p>
<p>To check if two matrices share common storage: </p>
<pre class="fragment">if (mtx_aliases_storage(m1, m2)) { ... }
</pre><p>To copy the elements from one matrix to another, without referencing, and regardless of matrix type or static/dynamic setting: </p>
<pre class="fragment">mtxcopy(&amp;dst_mtx, src_mtx);
</pre><p>Because of difference in storage strategy between static and dynamic matrices, copy and pass-by-value operations can be much heavier for large static matrices, because the entire matrix must be copied. Therefore it may be advisable to choose dynamic matrices for any data much larger than a few elements along each axis.</p>
<h2>Operators</h2>
<p>Matrices support most basic arithmetic operators. We'll demonstrate with these example objects: </p>
<pre class="fragment">SimpleMatrix&lt;double,3,3&gt; m1;
SimpleMatrix&lt;double,3,4&gt; m2;
Vec&lt;double,3&gt; v;
</pre><p>Inter-matrix mult: </p>
<pre class="fragment">m1 * m2
</pre><p>Matrix-scalar mult: </p>
<pre class="fragment">m1 * 3
1.618 * m1
</pre><p>Matrix-vector mult: </p>
<pre class="fragment">m1 * v
v * m2
</pre><p>Matrix addition / subtraction: </p>
<pre class="fragment">m1 + m1
m1 - m1
</pre><p>Equality test: </p>
<pre class="fragment">m1 == m1
m1 != m2
</pre><p>Indexing: </p>
<pre class="fragment">double x = m1[1][2];
m[0][1] = 2.718;
</pre><h2>Accessing elements</h2>
<p>Indexing: </p>
<pre class="fragment">// equivalent:
float f1 = m.get(2, 3);
float f2 = m[2][3]; 
</pre><p>Assignment: </p>
<pre class="fragment">// all equivalent:    
m.set(2, 3, val);
m[2][3] = val;
m.get(2, 3) = val;
</pre><p>Matrix body iterators: </p>
<pre class="fragment">typedef SimpleMatrix&lt;double,3,3&gt; mat3;
mat3 m;
// iterate over the matrix body in row-major order:
for (mat3::iterator i = mat.begin(), i != m.end(); m++) {
    *i = ... ;
}
</pre><p>Matrix region iterators: </p>
<pre class="fragment">typedef SimpleMatrix&lt;double,3,3&gt; mat3;
mat3 m;
Rect2i r = Rect2i(Vec2i(1,1), Vec2i(3,2));
// iterate over the elements in region `r` in row-major order:
for (mat3::region_iterator i = m.region_begin(r); i != m.region_end(r); i++) {
    Vec2i c = i.point();
    *i = f(p, ...);
}
</pre><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa4a33c0f1bb911ce5235ceb09dca799a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::add </td>
          <td>(</td>
          <td class="paramtype">Md *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ma &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mb &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classgeom_1_1_matrix.html" title="A generic matrix class which can hold references to all other matrix types.">Matrix</a> addition. Add the corresponding elements of <code>a</code> and <code>b</code>, whose dimensions must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>A writeable matrix, whose dimensions must match <code>a</code> and <code>b</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15d4fd8bba9f23ca2fb70cd0d4770f63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Md geom::add </td>
          <td>(</td>
          <td class="paramtype">const Ma &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mb &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classgeom_1_1_matrix.html" title="A generic matrix class which can hold references to all other matrix types.">Matrix</a> addition. Add the corresponding elements of <code>a</code> and <code>b</code>, whose dimensions must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix containing <code>a + b</code>, usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements.">SimpleMatrix</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga289fd7275b5cabfe4506146872626c29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geom::inv </td>
          <td>(</td>
          <td class="paramtype">Md *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mx &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classgeom_1_1_matrix.html" title="A generic matrix class which can hold references to all other matrix types.">Matrix</a> inversion. <code>src</code> and <code>into</code> must be square matrices of the same dimension. If a runtime check for square dimensions fails, a <code>NonsquareMatrixException</code> is raised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">into</td><td>A writeable matrix with dimensions equal to <code>src</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>A square matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the matrix is singular and could not be inverted, <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gafd2ee70cec8b19d14ac6227faaaf022f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Md geom::inv </td>
          <td>(</td>
          <td class="paramtype">const Mx &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classgeom_1_1_matrix.html" title="A generic matrix class which can hold references to all other matrix types.">Matrix</a> inversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A square matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">success</td><td>Will be set to <code>false</code> if the matrix was singular and could not be inverted, otherwise will be set to <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix containing the inverse of <code>m</code>, or undefined data if <code>m</code> could not be inverted. </dd></dl>

</div>
</div>
<a class="anchor" id="gab21d5043e723f853c25239014392b5f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geom::mtx_aliases_storage </td>
          <td>(</td>
          <td class="paramtype">const Ma &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mb &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do two matrices / vectors share storage?</p>
<p>In other words, might writing to one object change the contents of the other? <code>Ma</code> and <code>Mb</code> must be matrix or vector types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix or vector object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix or vector object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if writing to <code>a</code> may alter <code>b</code> or vice versa; <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga33456f94a9ec6f71bf5bd3016ec787e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::mtxcopy </td>
          <td>(</td>
          <td class="paramtype">Md *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ms &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the contents of <code>src</code> into <code>into</code>. This function may be optimized to perform better than running <code>std::copy()</code> on some matrix types' iterators. It will also succeed in certain situations where <code>std::copy()</code> would fail (for example when copying the contents of a diagonal matrix to another, any attempt to write off the diagonal will throw an exception).</p>
<p><code>Md</code> and <code>Ms</code> must be matrix or vector types whose dimensions match. If the dimensions can be determined to mismatch at compile-time, the program is considered invalid and the compilation will fail. If either object has dynamic size, the check will be deferred to runtime, throwing a <code>DimensionMismatchException</code> if the check fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">into</td><td>A writeable matrix with dimensions matching <code>src</code>'s. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>A matrix object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1f2513740215784239349db200787eac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Md&amp; geom::mul </td>
          <td>(</td>
          <td class="paramtype">Md *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ma &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mb &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix * matrix and matrix * vector multiplication</p>
<p>This function handles all multiplication between any two types of matrix, or between any matrix and a vector. Thus, <code>Ma</code>, <code>Mb</code>, (the operands) and <code>Md</code> (the destination), may each be either a matrix or a vector. If the left operand is a vector, it is assumed to be a row vector, whereas right vector operands are column vectors.</p>
<p>This function ensures that all compile-time checkable dimensions agree&ndash; that is to say, that <code>(a x b) * (b x c) = (a x c)</code> holds. If any object has a dynamic size, then the check will be deferred to runtime, and a DimensionMismatchException thrown if the check fails. A compile-time dimension mismatch implies the program is invalid and compilation will error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">into</td><td>A writeable matrix or vector with dimensions <code>(a.rows() x b.cols())</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object or vector with dimension <code>(N x b.rows())</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object or vector with dimension <code>(a.cols() x N)</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab6fff1cabd69e3baba0e775e0afe9ca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Md geom::mul </td>
          <td>(</td>
          <td class="paramtype">const Ma &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mb &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classgeom_1_1_matrix.html" title="A generic matrix class which can hold references to all other matrix types.">Matrix</a> multiplication.</p>
<p><code>Ma</code> and <code>Mb</code> may either be matrices or vectors. Left operands are, if vectors, assumed to be rows, while right operands will be treated as columns. The dimensions of <code>a</code> and <code>b</code> must satisfy <code>(a x b) * (b x c)</code>. If the dimensions can be determined to mismatch at compile time, the program is considered invalid and will not compile. If either argument has dynamic size, the dimension check will be performed at runtime, raising a <code>DimensionMismatchException</code> if it fails.</p>
<p>The return type will be chosen appropriately based on the arguments, and will have dimension <code>(a x c)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object or vector with dimension <code>(N x b.rows())</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object or vector with dimension <code>(a.cols() x N)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix or vector object containing the result of <code>a * b</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gae40b28b9ab295b246f08a49e6b3d99fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geom::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Ma &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mb &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix != matrix.</p>
<p>Matrices <code>a</code> and <code>b</code> are unequal unless <code>a</code> and <code>b</code> have the same dimension and all corresponding elements are equal. </p>

</div>
</div>
<a class="anchor" id="ga0002aa703c848adc96acb4714785baaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mx geom::operator* </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mx &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>scalar * matrix</p>
<p>All elements of <code>m</code> are multiplied by <code>k</code>. <code>Mx</code> must be a matrix type, and <code>U</code> must satisfy <code>boost::is_scalar&lt;U&gt;</code>. </p>

</div>
</div>
<a class="anchor" id="ga948c769c294a93b817cb05f1c2a15eeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mx geom::operator* </td>
          <td>(</td>
          <td class="paramtype">const Mx &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix * scalar</p>
<p>All elements of <code>m</code> are multiplied by <code>k</code>. <code>Mx</code> must be a matrix type, and <code>U</code> must satisfy <code>boost::is_scalar&lt;U&gt;</code>. </p>

</div>
</div>
<a class="anchor" id="ga2cf1ff3da39cde1d3419a32a4343dc20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mx geom::operator* </td>
          <td>(</td>
          <td class="paramtype">const Ma &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mb &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix * matrix</p>
<p><a class="el" href="classgeom_1_1_matrix.html" title="A generic matrix class which can hold references to all other matrix types.">Matrix</a> multiplication is performed on <code>a</code> and <code>b</code>.</p>
<p><code>Ma</code> and <code>Mb</code> may either be matrices or vectors (but may not <em>both</em> be vectors; this is handled by a different multiplication operator). Left operands are, if vectors, assumed to be rows, while right operands will be treated as columns. The dimensions of <code>a</code> and <code>b</code> must satisfy <code>(a x b) * (b x c)</code>. If the dimensions can be determined to mismatch at compile time, the program is considered invalid and will not compile. If either argument has dynamic size, the dimension check will be performed at runtime, raising a <code>DimensionMismatchException</code> if it fails.</p>
<p>The return type will be chosen appropriately based on the arguments, and will have dimension <code>(a x c)</code>. </p>

</div>
</div>
<a class="anchor" id="ga6502d1b57b8306893b83c0acf776bd7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mx geom::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Ma &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mb &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix + matrix</p>
<p>Add the elements of <code>a</code> and <code>b</code>. The return type will be chosen appropriately based on the arguments (usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements.">SimpleMatrix</a></code>). <code>Ma</code> and <code>Mb</code> must both be matrix types. </p>

</div>
</div>
<a class="anchor" id="gada3c858a1219dc51e34e8c6eff00d155"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mx geom::operator- </td>
          <td>(</td>
          <td class="paramtype">const Ma &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mb &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix - matrix.</p>
<p>Subtract the elements of <code>b</code> from <code>a</code>. The return type will be chosen appropriately based on the arguments (usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements.">SimpleMatrix</a></code>). <code>Ma</code> and <code>Mb</code> must both be matrix types. </p>

</div>
</div>
<a class="anchor" id="ga5acc85c8aa5280f24693d04b24855589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geom::operator== </td>
          <td>(</td>
          <td class="paramtype">const Ma &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mb &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>matrix == matrix.</p>
<p>Matrices <code>a</code> and <code>b</code> are equal if and only if <code>a</code> and <code>b</code> have the same dimension and all corresponding elements are equal. <code>Ma</code> and <code>Mb</code> must both be matrix types. </p>

</div>
</div>
<a class="anchor" id="ga4972da3cb8b6c6a34ef1615caad4bb1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::scale </td>
          <td>(</td>
          <td class="paramtype">Md *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mx &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scalar muliplication on matrices. In other words, multiply all the elements of <code>m</code> by scalar value <code>k</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>A writeable matrix, whose dimensions must match those of <code>m</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Scalar constant (whose type satisfies <code>boost::is_scalar&lt;U&gt;</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td><a class="el" href="classgeom_1_1_matrix.html" title="A generic matrix class which can hold references to all other matrix types.">Matrix</a> object to be scaled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga50aba1796182cf79911df6fd74d7494f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mx geom::scale </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mx &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scalar muliplication on matrices. In other words, multiply all the elements of <code>m</code> by scalar value <code>k</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Scalar constant (whose type satisfies <code>boost::is_scalar&lt;U&gt;</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td><a class="el" href="classgeom_1_1_matrix.html" title="A generic matrix class which can hold references to all other matrix types.">Matrix</a> object to be scaled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scaled copy of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ca8a4cc286eb011023e4c4adae9e27b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::sub </td>
          <td>(</td>
          <td class="paramtype">Md *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ma &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mb &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classgeom_1_1_matrix.html" title="A generic matrix class which can hold references to all other matrix types.">Matrix</a> subtraction. Subtract the corresponding elements of <code>b</code> from <code>a</code>'s. The dimensions of <code>a</code> and <code>b</code> must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>A writeable matrix, whose dimensions must match <code>a</code> and <code>b</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>A matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>A matrix object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacb3d20f8e69be52e491533ecbba17cbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Md geom::sub </td>
          <td>(</td>
          <td class="paramtype">const Ma &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mb &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classgeom_1_1_matrix.html" title="A generic matrix class which can hold references to all other matrix types.">Matrix</a> subtraction. Subtract the corresponding elements of <code>b</code> from <code>a</code>'s. The dimensions of <code>a</code> and <code>b</code> must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td><a class="el" href="classgeom_1_1_matrix.html" title="A generic matrix class which can hold references to all other matrix types.">Matrix</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td><a class="el" href="classgeom_1_1_matrix.html" title="A generic matrix class which can hold references to all other matrix types.">Matrix</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix containing <code>a - b</code>, usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements.">SimpleMatrix</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga293381c8fe7ffa4ed9889db1f4ca7787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geom::transpose </td>
          <td>(</td>
          <td class="paramtype">Md *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mx &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classgeom_1_1_matrix.html" title="A generic matrix class which can hold references to all other matrix types.">Matrix</a> transpose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">into</td><td>A writeable matrix with dimensions <code>(m.cols(), m.rows())</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A matrix object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7817e9ff690b0dbf2baa4475bbd5f8ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Md geom::transpose </td>
          <td>(</td>
          <td class="paramtype">const Mx &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classgeom_1_1_matrix.html" title="A generic matrix class which can hold references to all other matrix types.">Matrix</a> transpose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A matrix object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A transposed copy of <code>m</code>, of type appropriate for the argument, usually a <code><a class="el" href="classgeom_1_1_simple_matrix.html" title="A basic matrix with M x N elements.">SimpleMatrix</a></code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 11 2013 00:02:26 for geomc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
